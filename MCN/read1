4.3 Address Striping
IPWNRB A system typically stripes its address space between a number of memory channels, in this case MCN instances, to
improve the performance by balancing the memory accesses between the memory channels

Address striping must be supported by the DSU as defined in 4.3 Address Striping.
Address striping must be supported by the NCI as defined in 4.3 Address Striping.

RXDNBK Address striping is applied to the physical address in the case of the DSU .
RLQRFP Address striping is applied to the transaction address in case of the NCI.

RTJSFB The address striping capabilities of the DSU and NCI must match.
RWVQBH The minimal address stripe granule is 256bytes.
RVYPNQ Before address striping is applied the component performs an address decode to route the transaction to the correct
interface or stripe group.

4.3.1 Stripe algorithm
IWJWPD The stripe algorithm used to calculate which port an address belongs to depends on the number of ports which are
enabled in the stripe group.
RZXGFQ Both DSU and NCI must support the following stripe algorithms:
‚Ä¢ Hash
‚Ä¢ Modulo

RFCPHG Both stripe algorithms are configured using reset time sampled inputs.
XWJTZB This allows the algorithm to be modified so that macros can be re-used between different SoC designs or the same
SoC can be used with different memory configurations.


+++++++++++++++++
HASH STRIPE ALGO
+++++++++++++++++
Excellent question ‚Äî short answer: no, this is not a standard general-purpose hashing algorithm ‚Äî it‚Äôs a hardware-specific, deterministic hash function designed for memory striping and address interleaving.

Let‚Äôs break it down clearly üëá

‚∏ª

üß© 1. What ‚ÄúStandard Hashing‚Äù Usually Means

When people talk about ‚Äúhashing‚Äù in software or computer science, they typically refer to:
	‚Ä¢	Data hashing for maps, checksums, or cryptography.
Examples: CRC32, SHA-256, MurmurHash, Jenkins, FNV, etc.
	‚Ä¢	The goals there are:
	‚Ä¢	To evenly distribute arbitrary data.
	‚Ä¢	To avoid collisions (different inputs ‚Üí same hash).
	‚Ä¢	To be fast and non-reversible.

Those standard hash algorithms use polynomial arithmetic, rotations, and mixing constants ‚Äî far more complex than simple XOR.

‚∏ª

‚öôÔ∏è 2. What This Algorithm Actually Does

This function:
stripe_group_port_sel(address, mask)
	‚Ä¢	Be easy to implement in hardware (few gates, no loops at runtime).

‚∏ª

üß† 3. Why XOR Is Used Here

In hardware, XOR is the cheapest way to ‚Äúmix‚Äù bits:
	‚Ä¢	Each XOR can be computed in 1 logic level.
	‚Ä¢	Combining multiple XORs still keeps propagation delay low.
	‚Ä¢	It gives an approximately uniform distribution if addresses vary naturally.

So, by XORing certain address bits:
	‚Ä¢	The algorithm spreads consecutive addresses across different VMIs.
	‚Ä¢	For example:
	‚Ä¢	Address 0x0000_0000 maps to port 0
	‚Ä¢	Address 0x0000_0100 maps to port 1
	‚Ä¢	Address 0x0000_0200 maps to port 2
	‚Ä¢	etc.

This makes memory access load-balanced.

‚∏ª

üèóÔ∏è 4. Where It‚Äôs Typically Used

This algorithm (or variations of it) appear in:
	‚Ä¢	ARM‚Äôs DSU (DynamIQ Shared Unit) documentation.
	‚Ä¢	Memory controllers that stripe cache lines across memory banks.
	‚Ä¢	Interconnect fabrics that distribute traffic to ports evenly.
	‚Ä¢	NUMA and memory channel hashing.
---------------EXAMPLE
üß† Purpose of the Algorithm

This function determines which VMI (Virtual Machine Interface) to use for a given memory address.
It‚Äôs a load-balancing or address-striping mechanism: the same data range is spread evenly across multiple VMIs (like channels or memory ports).

When there are 2, 4, or 8 VMIs, it calculates a port index (0 to N‚àí1) based on the address bits.

‚∏ª

‚öôÔ∏è Step-by-Step Explanation

1Ô∏è‚É£ Inputs
	‚Ä¢	address: 64-bit memory address (e.g., 0x12345678ABCD).
	‚Ä¢	mask: 64-bit bitmask (defines which address bits are considered).
	‚Ä¢	NUM_VMI_EN: number of enabled VMIs (2, 4, or 8).

‚∏ª

2Ô∏è‚É£ Ignore low 8 bits

Because striping granularity is 256 bytes, the lowest 8 bits (bit[7:0]) are ignored:
tmp_mask = mask & 0xFFFFFFFFFFFFFF00;
So we only consider address bits [63:8].

‚∏ª

3Ô∏è‚É£ Apply mask to address
mask_addr = address & tmp_mask;
Depending on NUM_VMI_EN:

Case 1: 2 VMIs
	‚Ä¢	XOR all bits together ‚Üí 1-bit result.
	‚Ä¢	Output is either 0 or 1.

Case 2: 4 VMIs
	‚Ä¢	Separate bits into even and odd positions.
	‚Ä¢	XOR all even bits together ‚Üí gives 1 bit.
	‚Ä¢	XOR all odd bits together ‚Üí gives 1 bit.
	‚Ä¢	Combine to get a 2-bit number (range 00‚Äì11).

Case 3: 8 VMIs
	‚Ä¢	Group bits into triplets (bit 0‚Äì2, 3‚Äì5, 6‚Äì8, etc.).
	‚Ä¢	XOR bits that fall into the same ‚Äúmod 3‚Äù group.
	‚Ä¢	Combine to get a 3-bit number (range 000‚Äì111).

‚∏ª

üí° Example Walkthrough

Let‚Äôs assume:
Parameter                          Value
NUM_VMI_EN                           4
address                      0x0000_0000_0000_12C0
mask                         0xFFFF_FFFF_FFFF_FF00

Step 1: Ignore bits [7:0]

So we use address bits [63:8]:
address = 0x12C0 ‚Üí binary: 0001 0010 1100 0000
Step 2: Apply mask
mask_addr = address & mask = 0x0000_0000_0000_1200
Binary (bits 15‚Äì8): 0001 0010

Step 3: XOR logic for 4 VMIs
	‚Ä¢	Even bits (positions 8,10,12,14): 0,1,0,0 ‚Üí XOR = 1
	‚Ä¢	Odd bits  (positions 9,11,13,15): 0,0,1,0 ‚Üí XOR = 1

Combine:
port_select = (odd XOR result << 1) | even XOR result
= (1 << 1) | 1 = 3 (binary 11)

‚úÖ So this address maps to port 3 (VMI #3).


With this document, can you help me understand MCN does address shuttering or address striping ?

Great question ‚Äî based on the MCN architecture specification you provided, here‚Äôs a clear explanation:

‚∏ª

üß† What MCN Does: Address Striping vs. Address Shuttering

The MCN (Memory Controller Node) performs address striping, but also uses a mechanism called address shuttering as a post-processing step to clean up (‚Äúcompact‚Äù) the address space after striping.
Let‚Äôs unpack that distinction.

‚∏ª

üß© 1. Address Striping ‚Äî The Primary Function

The MCN supports address striping to distribute memory accesses evenly across multiple memory channels (MCNs).
From the specification:

‚ÄúA system typically stripes its address space between a number of memory channels, in this case MCN instances, to improve the performance by balancing the memory accesses between the memory channels.‚Äù Ôøº

Key details:
	‚Ä¢	Address striping happens when 2 or more master ports are grouped into a stripe group.
	‚Ä¢	The DSU (core cluster) and NCI (NoC interface) both use striping to spread load evenly Ôøº.
	‚Ä¢	Two stripe algorithms are defined:
	‚Ä¢	Hash algorithm for 2, 4, or 8 VMIs (using XOR mixing) Ôøº.
	‚Ä¢	Modulo algorithm for 3 or 6 VMIs (bit selection and modulo-based calculation) Ôøº.

This confirms MCN implements address striping as a key design feature ‚Äî its purpose is performance balancing.

‚∏ª

üßÆ 2. Address Shuttering ‚Äî A Secondary Cleanup Stage

Later in the document (section 4.3.2 ‚ÄúMCN outbound address‚Äù), there‚Äôs mention of address shuttering:

‚ÄúWhen applying address striping there is a requirement to remove certain address bits from the address of the outbound transaction to close the holes which are introduced by the striping.‚Äù Ôøº

This means that after the address has been striped (i.e., distributed across multiple MCNs), there are ‚Äúholes‚Äù in the address map ‚Äî because some bits are used only to choose which MCN to go to.
The address shutter logic removes those bits before the address goes to DRAM, compacting it back into a contiguous space.

Software programs an address_shutter register to select which bits to keep or exclude from the outgoing address. The specification explicitly defines it as:

‚ÄúSoftware uses the address_shutter register to select the bits to include and exclude from the output address.‚Äù Ôøº

And the appendix clarifies:

‚Äúaddress_shutter ‚Ä¶ bit select field for all of the incoming address bits. Used to close holes created due to upstream striping.‚Äù Ôøº

So, address shuttering = bit compaction, not distribution.

‚∏ª

‚öôÔ∏è 3. Relationship Between the Two
Feature                   Purpose                                                  Where It Happens                 Mechanism
Address Striping     Distribute addresses across MCNs (channels)             Before memory scheduling            Hash or modulo algorithm on address bits
Address Shuttering     Remove stripe bits (‚Äúholes‚Äù) to make the address continuous again  After MSF & SLC, before memory scheduler address_shutter register logic shifts b

In short:
	‚Ä¢	Striping = spreading traffic.
	‚Ä¢	Shuttering = cleaning up address space after spreading.

üèÅ ‚úÖ Final Answer

The MCN performs address striping as its primary addressing mechanism.
However, it also implements address shuttering as a supporting feature to compact the striped addresses before sending them to the memory controller.

So, MCN does both:
	‚Ä¢	Address striping ‚Äî for performance/load balancing.
	‚Ä¢	Address shuttering ‚Äî for address space compaction.

But conceptually, MCN is fundamentally an address-striping component; shuttering is an auxiliary step that ensures correct address continuity post-striping.


+-----------------+        +-------------------+        +--------------------+        +----------------------+
|  Memory Request | -----> |  Address Striping | -----> |  Address Shuttering | -----> |  Memory Controller   |
+-----------------+        +-------------------+        +--------------------+        +----------------------+

Description:
1. Memory Request:
   - Incoming address request from DSU or NCI.

2. Address Striping:
   - Distributes memory requests across multiple MCN instances (channels).
   - Uses Hash or Modulo algorithm based on the number of enabled VMIs.

3. Address Shuttering:
   - Removes stripe bits from the address to "close holes" created by striping.
   - Compact address is then forwarded to DRAM via memory scheduler.

4. Memory Controller:
   - Receives the compacted (shuttered) address and executes the memory access.



                            





Read this: https://www.asic-world.com/tidbits/metastablity.html
https://www.edn.com/synchronizer-techniques-for-multi-clock-domain-socs-fpgas/
https://www.youtube.com/playlist?list=PLdcY8Cf-O1Zon-8c9NDhgY2F8r_O7oeC4
Must read: STA/CDC spiral notebook notes: Explained all CDC techniqus in details.

IQ -> Means -> Interview Questions

-------------------------------------------------
Can you see CDC failures in Simulation ?
-------------------------------------------------
No â€” you cannot truly see CDC issues (like metastability) in digital RTL simulation.
But you can simulate logical effects (like handshake bugs or missing pulses) that stem from poor CDC handlin

++++++++++++++++++++++++++++++++++++++++++++++++
ğŸ”¹ Core Synchronization Techniques
A. 2-flop synchronizer
B. Handshake (req/ack)
C. Toggle / pulse synchronizer
D. Asynchronous FIFO
E. Gray coding
++++++++++++++++++++++++++++++++++++++++++++++++



Ways of solving Metastability.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
A. letâ€™s master the 2-flop synchronizer step by step. This is the #1 CDC primitive for single-bit control/status signals.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
1) What problem it solves
When a signal from clock domain A is sampled in clock domain B, it may change too close to a B-domain clock edge â†’ the first flip-flop in B can go metastable (neither 0 nor 1 for a while). We canâ€™t prevent metastability, but we can contain it so downstream logic only ever sees a clean 0/1.
Idea: put two back-to-back flip-flops in the destination domain. The first one may go metastable; by the time the second one samples (one cycle later), the first has almost certainly resolved.

module sync_2ff (
    input  wire clk_dst,     // destination clock
    input  wire rst_n,       // active-low reset (sync deassert recommended)
    input  wire async_in,    // from another clock domain or async source
    output reg  sync_out     // safe in clk_dst domain
);
    // In FPGAs, these attributes help with placement/metastability hardening:
    // (* ASYNC_REG = "TRUE" *) reg s1;
    // (* ASYNC_REG = "TRUE" *) reg s2;

    reg s1, s2;

    always @(posedge clk_dst or negedge rst_n) begin
        if (!rst_n) begin
            s1 <= 1'b0;
            s2 <= 1'b0;
        end else begin
            s1 <= async_in;  // stage 1: may go metastable
            s2 <= s1;        // stage 2: captures a settled value
        end
    end

    assign sync_out = s2;
endmodule

Why it works: metastability duration decays exponentially. Giving it one extra clock cycle to settle makes the probability of â€œbadâ€ propagation astronomically small for typical clocks.

3) When to use (and when NOT to)
	â€¢	âœ… Use: single-bit level signals (enable, ready, interrupt, status).
	â€¢	âŒ Donâ€™t use: multi-bit buses (youâ€™ll get bit-skew). Use a handshake or an async FIFO instead.
  notes: Latency: introduces 1â€“2 cycles in clk_dst. Plan your control timing accordingly.

** IQ: Why two flip-flops and not one?
One flop can still be metastable and propagate uncertainty; the second flop gives one extra clock cycle for resolution, exponentially reducing failure probability.

** IQ: How would you synchronize multi-bit data?
2-FF synchronizer is not enough. Use handshake (req/ack) or asynchronous FIFO with gray-coded pointers.

** IQ:  What is the latency of a 2-FF synchronizer?
Two clock cycles in the destination domain (one for each flop).

** IQ: What factors affect metastability probability?
Clock frequency (destination), data toggle rate (source), flip-flop parameters (Ï„), and the allowed resolution time.

** IQ: Why can metastability still occur in the second flop?
Itâ€™s possible if the metastable value from the first flop hasnâ€™t resolved in time â€” but probability is extremely low.

** IQ: What happens if you add logic between the two flops?
It breaks the synchronizer; the metastable value can propagate and affect logic delay â†’ invalid design.

** IQ: If you have multiple destination domains using the same signal, can they share a single synchronizer?
No â€” each domain needs its own 2-FF chain.

** IQ: After using 2 FF synchronizers, it'll be sure that, if async_in data is 1, output will be 1 from the 2nd flip flop of a 2 FF synchronizer.
â€œA 2-FF synchronizer ensures the signal is stable and metastability is contained,
but it doesnâ€™t guarantee that the value sampled is the same as the current asynchronous input â€” especially if it toggles faster than the destination clock.
For guaranteed capture, weâ€™d need handshake or pulse-stretching mechanisms.â€

8ï¸âƒ£ What happens if the async input is a pulse?
Answer:
The pulse may be:
Missed completely
Stretched
Captured incorrectly

âœ”ï¸ Solutions:
Pulse stretcher
Toggle-based synchronizer
Handshake

IQ: A faster destination clock generally worsens metastability (reduces MTBF).

Your reasoning is correct.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
B. Handshake (req/ack)
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
ğŸ§­ 1. What a Handshake Synchronizer Does

A handshake (also called request/acknowledge synchronizer) is used to guarantee that an event or data word is transferred exactly once between two clock domains â€” even if their clocks are completely asynchronous.

Think of it like two people passing a note:
	â€¢	REQ (request) â†’ â€œHey, I have data for you.â€
	â€¢	ACK (acknowledge) â†’ â€œGot it. You can send the next one.â€

Unlike a 2-FF synchronizer, which only ensures signal stability,
a handshake also ensures reliability â€” the event wonâ€™t be missed.

âš™ï¸ 3. Basic Principle
Both domains use synchronizers on incoming signals.
   clk_src domain                          clk_dst domain
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚              â”‚                        â”‚              â”‚
   â”‚  REQ  â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º sync â–ºâ”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”       â”‚
   â”‚              â”‚                        â”‚      â”‚       â”‚
   â”‚  â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€ sync â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”˜       â”‚
   â”‚     ACK      â”‚                        â”‚   ACK        â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
1ï¸âƒ£ Source domain asserts REQ to indicate data/event is ready.
2ï¸âƒ£ Destination sees the synchronized REQ, processes it, then asserts ACK.
3ï¸âƒ£ Source sees synchronized ACK â†’ deasserts REQ.
4ï¸âƒ£ Destination sees REQ deasserted â†’ deasserts ACK.
ğŸ‘‰ Both return to idle (REQ=0, ACK=0), ready for the next event.

Simple explanation:
It ensures that:
The source sends data and asserts a request (req)
The destination receives the data, latches it, and sends back an acknowledge (ack)
The source waits for ack before sending the next data

4. Handshake Timing Diagram
clk_src    â”€â”  â”Œâ”€â”  â”Œâ”€â”  â”Œâ”€â”  â”Œâ”€â”  â”Œâ”€â”  â”Œâ”€â”  â”Œâ”€â”
            â”‚  â”‚ â”‚  â”‚ â”‚  â”‚ â”‚  â”‚ â”‚  â”‚ â”‚  â”‚ â”‚  â”‚
REQ_src     â”€â”€â”€â”â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
               â”‚<-- active until ACK -->â”‚

REQ_dst_sync â”€â”€â”€â”€â”€â”€â”€â”€â”â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                      â†‘ seen by dest

ACK_dst     â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                      â”‚<-- active until REQ drops -->

ACK_src_sync â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                           â†‘ seen by src

5. Interview-worthy Explanation
â€œA handshake synchronizer uses a request (REQ) and acknowledge (ACK) signal pair to safely communicate across asynchronous domains.
Each signal is synchronized in the opposite domain using 2-FF synchronizers.
The protocol ensures that every event is captured exactly once â€” even if the clocks are completely unrelated.â€

IQ. What problem does a REQ/ACK handshake solve that a 2-FF synchronizer cannot?
They want to hear: â€œ2-FF ensures stability but can miss short pulses; REQ/ACK ensures reliable event delivery even if clocks are asynchronous.â€

IQ. Why do we use synchronizers on both REQ and ACK?
Because both signals cross domains and can go metastable â€” each must be synchronized independently.

IQ. Can metastability occur in a handshake synchronizer?
Yes, in the synchronizer FFs â€” but metastability is contained, never propagates to logic.

IQ. What ensures that no events are lost?
The source keeps REQ high until it receives ACK_sync = 1.

IQ. What is the typical latency of one handshake?
~4 clock cycles (2 per domain), depending on relative clock frequencies.

IQ. Why must both REQ and ACK be level-signals, not pulses?
Because pulse width can be missed in async domains; levels are persistent until acknowledged.

âœ” Data is not synchronized
âœ” Only REQ/ACK are synchronized
âœ” Data is sampled only when stable

-----FOR THIS METHODOLOGY DO MORE QUESTIONS FROM CHATGPT
2ï¸âƒ£ Which signals are synchronized in a REQâ€“ACK scheme?
Expected answer
Only REQ and ACK
Data is not synchronized
Data is captured only when handshake is valid.

3ï¸âƒ£ How many flip-flops are used?
Expected answer
2 FFs for REQ sync (dest clock)
2 FFs for ACK sync (source clock)
1 FF for REQ
1 FF for ACK
â¡ï¸ Total = 6 control FFs (+ data regs)

4ï¸âƒ£ Where does metastability occur?
Only in the first FF of REQ sync
Only in the first FF of ACK sync
Never in data path

6ï¸âƒ£ Why canâ€™t we synchronize data bits directly?
Each bit may settle differently
Leads to data corruption
Handshake guarantees atomic transfer

7ï¸âƒ£ What happens if ACK arrives before REQ deasserts?
This is expected behavior
Source must wait for ACK before clearing REQ
Prevents lost transfers

IQ: Draw the state machine for REQ-ACK based synchronizer.
          +--------------------+
          |                    |
          |        IDLE        |
          |   REQ=0, ACK=0    |
          +---------+----------+
                    |
               start_transfer
                    |
                    v
          +--------------------+
          |                    |
          |   REQ_ASSERTED     |
          |     REQ=1          |
          +---------+----------+
                    |
              ACK_sync == 1
                    |
                    v
          +--------------------+
          |                    |
          |   WAIT_ACK_LOW     |
          |     REQ=0          |
          +---------+----------+
                    |
              ACK_sync == 0
                    |
                    v
                 (IDLE)
States
IDLE - no transfer
REQ_ASSERTED â€“ request sent
WAIT_ACK_LOW â€“ waiting for ACK deassert

IQ.  Why wait for REQ deassert?
Prevents double sampling
Guarantees exactly-once transfer
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
C . Toggle / pulse synchronizer   -  NOT READ IN DETAILS
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Note: Pulse synchronizers are of 2 types:
1. Level Based
2. Toggle based

2	. Toggle based Synchronizer:
Read from STA/CDC spiral notebook

IQ:Why do we use a toggle instead of directly synchronizing a pulse?
Trap intent: Pulse width misconception
Expected answer:
A pulse can be shorter than the destination clock period and get missed
Toggle converts event â†’ level change
Level change is guaranteed to be captured eventually

2ï¸âƒ£ Why is an XOR used instead of AND/OR to generate the pulse?
Expected thinking:
XOR detects any transition
AND/OR depend on absolute values
XOR gives pulse on both rising and falling edges
âœ”ï¸ Correct: pulse = curr ^ prev

3ï¸âƒ£ What happens if two source pulses occur before the destination clock samples the toggle?
Very common trap
Answer:
Toggle flips twice
Destination sees no net change
â— Event is lost
ğŸ‘‰ Toggle synchronizers are not event counters

4ï¸âƒ£ Can a toggle synchronizer guarantee delivery of every pulse?
Answer: âŒ No
Explanation:
It guarantees detection of a change, not every event
For multiple events â†’ need:
Gray counter synchronizer
FIFO

6ï¸âƒ£ Is metastability still possible in a toggle synchronizer?
Expected answer:
Yes, but contained
First FF can go metastable
Second FF reduces probability
XOR only sees clean, registered signals

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
D. Asynchronous FIFO
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Most powerful and advanced CDC technique
This is the go-to method when you need to transfer multi-bit data streams between independent clock domains â€” safely, continuously, and without metastability corrupting the data.
So far weâ€™ve covered:
	â€¢	âœ… 2-FF synchronizer â†’ transfers stable 1-bit levels (may miss pulses).
	â€¢	âœ… Handshake (REQ/ACK) â†’ transfers 1-bit events reliably (but slow) (can be used to transfer multi bit data).
	â€¢	âœ… Toggle synchronizer â†’ transfers short pulses/events (still 1-bit).

But what if we need to:
	â€¢	Transfer multi-bit data (like a byte, word, or packet)?
	â€¢	Support continuous data flow (not one event at a time)?
	â€¢	Handle independent clock frequencies (e.g., write @ 125 MHz, read @ 200 MHz)?

ğŸ‘‰ Thatâ€™s where we need an Asynchronous FIFO.

Conceptual Overview

An asynchronous FIFO allows one clock domain (writer) to push data,
while another independent domain (reader) pops data â€” safely.

It uses:
	â€¢	Separate write clock (wr_clk) and read clock (rd_clk)
	â€¢	Separate pointers for each domain
	â€¢	Gray-coded pointers that cross domains safely
	â€¢	2-FF synchronizers for those pointers
	â€¢	Empty/full flags for flow control

      WRITE DOMAIN (wr_clk)                      READ DOMAIN (rd_clk)
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚                          â”‚               â”‚                          â”‚
 â”‚   Write Data (wr_data)   â”‚               â”‚        Read Data         â”‚
 â”‚       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚               â”‚       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
 â”‚       â”‚ Write Addr â”‚â”€â”€â”€â”€â–ºâ”‚               â”‚â—„â”€â”€â”€â”€â”€â”€â”‚ Read Addr  â”‚     â”‚
 â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚               â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
 â”‚       â”‚ Write Ptr Grayâ”‚â—„â”€â”¼â”€â”€syncâ”€â”€â”   â”Œâ”€â”€â”¼â”€â–ºâ”‚ Read Ptr Grayâ”‚        â”‚
 â”‚                          â”‚   (2-FF)â”‚     â”‚(2-FF)                    â”‚
 â”‚                          â”‚          â”‚    â”‚                          â”‚
 â”‚        FIFO Memory        â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â–º                 â”‚
 â”‚     (Dual-Port RAM)       â”‚          â”‚   â”‚                       â”‚
 â”‚                          â”‚          â”‚   â”‚                       â”‚
 â”‚ full/empty flags generatedâ”‚          â”‚   â”‚                       â”‚
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â””â”€â”€â”€â”˜                       â””â”€â”€


Why Gray Code?

Binary counter transitions (e.g., 0111 â†’ 1000) flip many bits at once â†’ possible metastability & misinterpretation.
Gray code transitions only one bit at a time, so even if metastability occurs, at most one bit is uncertain â†’ no invalid pointer values.

IQ. How is metastability avoided?
By using 2-FF synchronizers on Gray-coded pointers.

IQ. Why use Gray code pointers?
Only one bit changes per increment, reducing metastability uncertainty.

IQ. What happens if clocks are completely unrelated?
FIFO still works â€” design is fully asynchronous.

IQ. How many synchronizers are needed?
Two: one for writeâ†’read pointer, and one for readâ†’write pointer.

âœ… In summary:

An Asynchronous FIFO is the industry-standard CDC mechanism for multi-bit data transfer.
It uses dual-clock RAM, Gray-coded pointers, and 2-FF synchronized pointer exchanges between domains.
It guarantees safe, continuous, and metastability-free data transfer between asynchronous clocks.


IQ. Why is metastability still possible but not harmful?
Because it may affect only the pointer sync FFs, but flags and data access tolerate it due to Gray code and timing margins.

IQ. How many 2-FF synchronizers are needed?
Two total: one for sending write pointer to read domain, one for sending read pointer to write domain.

IQ. What can go wrong if you use binary counters for pointers instead of Gray code?
Multiple bits toggle â†’ receiver can read incorrect intermediate values â†’ false full/empty flags â†’ data corruption.


+++++++++++++++++++ General CDC Question ++++++++++++++++++++++++++++++++++++++++++
ğŸ”¥ 2ï¸âƒ£ Why is a pulse dangerous in CDC, but a level is safer?
Expected Answer
Pulse may be missed if destination clock doesnâ€™t sample it
Level remains asserted long enough to be synchronized
Golden Line
â€œA pulse is an event; a level is a state. Events are hard to synchronize.â€

swapping of 2 variables a,b in verilog:

which one can we use: 
Case1
always@(posedge clk)
a=b

always@(posedge clk)
b=a

case 2
always@(posedge clk)
a<=b

always@(posedge clk)
b<=a

Case 3
always@(posedge clk)
a<=b
b<=a

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
in below verilog code:
always @(posedge clk)  //always block1 
    x = y; 

always @(posedge clk) // always block 2 
    z = m; 

which will execute first ?

âœ… Both blocks are triggered at the SAME time, and
â— Verilog does NOT define which one executes first.
âœ” Correct answer: The order is UNDEFINED.

Verilog's event scheduler places both blocks in the active region for posedge clk.
When multiple always blocks are sensitive to the same event, they can be executed in any order, and that order:
Is NOT specified by the language
Can differ between simulators
Can differ between simulation runs
Cannot be relied upon

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
in below verilog code:
always @(posedge clk)  //always block1 
   #5; x = y;  

always @(posedge clk) // always block 2 
    z = m; 

which will execute first ?

Short answer:
â­ Block 2 will execute first. Long answer with explanation below.
âœ” Why Block 2 executes first

Step-by-step event scheduler behavior:
ðŸŸ© 1. posedge clk happens â†’ both blocks are triggered
Both always @ (posedge clk) blocks enter the Active Region.

ðŸŸ© 2. Verilog starts executing Block 1
Inside Block 1:
#5;x = y;
The first statement is a delay (#5).
A delay moves execution of the rest of the block into a future event,
NOT continuing inside Active Region.
So:At time T, Block 1 reaches #5,
It suspends execution,
And schedules the remaining statement (x = y) at time T + 5.
So Block 1 does NOT execute x = y now.

ðŸŸ© 3. Block 2 executes immediately
Block 2 has no delay:
z = m;   // runs immediately in Active Region

So at time T, Block 2 finishes completely.
ðŸŸ© 4. After 5 time units (time = T + 5)
Block 1 wakes up and executes:
x = y;
â­ Final Execution Order (Timeline)
Time = T (posedge clk):
Block 1 starts â†’ hits #5, suspends
Block 2 executes completely â†’ z = m
Time = T + 5:
3. Block 1 resumes â†’ x = y

â­ Final Answer
Time	What happens
T	Block 2 executes first â†’ z = m
T + 5	Block 1 executes â†’ x = y

So:âœ” Block 2 executes first
because Block 1 is delayed by #5 before doing x = y.
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
what is difference between Code1 and code2

Code1:
always@(posedge clk)
x=y;

always@(posedge clk)
z=m;

Code2:
always@(posedge clk)
begin
x=y;
z=m;
end

Code1:
âœ” Meaning:
Two separate sequential processes
Both triggered by posedge clk
Both update their variables on each clock edge
â— Order between the two blocks is NOT defined
Verilog does not specify which block runs first.

â­ Code 2 â€” One Always Block
âœ” Meaning:
One sequential process
Triggered by posedge clk
Statements execute in fixed order (x=y executes first, then z=m)

â­ Do they generate the same hardware?
âœ” Yes â€” if the signals are independent

| Aspect                  | Code 1                         | Code 2                           |
| ----------------------- | ------------------------------ | -------------------------------- |
| Number of always blocks | 2                              | 1                                |
| Execution order         | **Undefined**                  | **Fixed: x=y first, z=m second** |
| Risk of race            | Possible (if dependent)        | None                             |
| Synthesized hardware    | Same (for independent x and z) | Same                             |

â­ Final Conclusion
Functionally and for synthesis, Code1 and Code2 are the same because x and z are independent.
But Code2 is safer and deterministic.
Because all related registers are updated inside the same clocked always block.
If you'd like, I can show cases where Code1 gives wrong results but Code2 works correctly.

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                                                                           SEQUENTIAL BLOCK
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
in below verilog code:
always @(posedge clk)  //always block1 
    x <= y; 

always @(posedge clk) // always block 2 
    z <= m; 

â­ Which always block executes first?
âœ” Both blocks are triggered at the same time.
âœ” Their execution order is NOT defined by Verilog.
âœ” Either block may execute first.
Thatâ€™s the correct answer.
â­ But here is the important part:
Because you are using non-blocking assignments (<=), the execution order does NOT matter.
Why?
â­ How non-blocking (<=) works
When the simulator hits:
x <= y; or z <= m;
it does not update x or z immediately.
Instead:
The RHS (y or m) is evaluated now
The LHS update (x or z) is scheduled for later (NBA region)
So both of these go into the NBA queue, regardless of which block executed first.
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
what is difference between Code1 and code2
Code1:
always@(posedge clk)
x<=y;
always@(posedge clk)
z<=m;

Code2:
always@(posedge clk)
begin
x<=y;
z<=m;
end

Here is the precise and correct difference between Code1 and Code2.

â­ Code 1 â€” Two clocked always blocks
always @(posedge clk)
    x <= y;
always @(posedge clk)
    z <= m;

âœ” Meaning
Two separate sequential processes
Both triggered by the same posedge clk
Both execute in the NBA region (non-blocking)
â— Execution order is undefined
Verilog does not guarantee whether block1 or block2 is simulated first.
âœ” But result is always correct
Because <= (non-blocking) schedules updates later, execution order does not affect final values.
âœ” Synthesizes to:
One flip-flop for x
One flip-flop for z

â­ Code 2 â€” One clocked always block
always @(posedge clk) begin
    x <= y;
    z <= m;
end

âœ” Meaning
One sequential process
Statements run in fixed order: x<=y first, then z<=m
But because both are <=, they still update together in NBA region
âœ” Synthesizes to:
Same flip-flop for x
Same flip-flop for z

â­ Functional Comparison
Aspect	Code 1	Code 2
| Aspect                      | Code 1                         | Code 2    |
| --------------------------- | ------------------------------ | --------- |
| # always blocks             | 2                              | 1         |
| Execution order             | **Undefined**                  | **Fixed** |
| Updates done in NBA region? | âœ” Yes                          | âœ” Yes     |
| Race possible?              | âŒ No (because RHS independent) | âŒ No      |
| Synthesized hardware        | **Same**                       | **Same**  |

â­ Final Answer

Code1 and Code2 generate exactly the same hardware and behave the same,
because:
Both use non-blocking assignments
RHS signals (y and m) are independent
Updates happen in the NBA region simultaneously
The only difference:
Code1 uses two processes with undefined execution order
Code2 uses one process with defined ordering (but irrelevant because of <=)
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                                                            SOME TRICKY INTERVIEW QUESTIONS RELATED TO THIS
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
âœ… Hard questions
âœ… Multiple-choice questions
âœ… Debug-the-code questions
âœ… Coding-round Verilog exercises
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
â­ 6. Tricky synthesis question
Question: What hardware is synthesized from:
assign x = y;
Answer:A combinational wire from y to x. No flip-flop.

â­ 8. Blocking vs Non-blocking trick
Question: Inside one always block:
always @(posedge clk) begin
    a = b;
    c <= a;
end

What does c get?
Answer: c gets the old value of a, NOT the new one.
Explanation
a = b executes in Active region â†’ immediate update
But c <= a is evaluated using old a, because NBA region always uses old values.
This is one of the most frequent interview traps.
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                                                  âœ… Hard questions: ðŸ”¥ Hard & Tricky Verilog Interview Questions (With Answers)
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
1ï¸âƒ£ Two always blocks, same clock, non-blocking assignment
Question:always @(posedge clk)
    x <= y;
always @(posedge clk)
    z <= x;

Assume y = 5 at this clock edge. What value will z get after the clock?

Answer
z gets the old value of x, not 5.
Why?

Non-blocking assignments (<=) update at the end of the time-step, in the NBA region.
Both always blocks read old values and schedule updates.
So:
Block1: schedules x = y_old
Block2: schedules z = x_old
Order doesnâ€™t matter at all.
Both read the pre-clock values.

2ï¸âƒ£ Blocking vs non-blocking interaction between two always blocks
Question
always @(posedge clk)
    x = y;   // blocking

always @(posedge clk)
    z = x;   // blocking


Is there a possible race?
Will z get y or old x?

Answer

Yes, a race condition exists.

The order of execution of the two always blocks is undefined, so:

If block1 executes first â†’ x=y â‡’ block2 sees new x

If block2 executes first â†’ sees old x (race)

Never mix blocking assignments between two clocked always block
6ï¸âƒ£What is wrong with this?

always @(*) begin
    if (en)
        q = d;
end
Answer:Latch inferred because q is not assigned when en = 0.

7ï¸âƒ£ Race condition when multiple drivers exist
Question
always @(posedge clk) x <= a;
always @(posedge clk) x <= b;
What happens?
Answer
Illegal â€” multiple drivers to same register.
Synthesis error.
9ï¸âƒ£ What does this Verilog slice mean?
5ï¸âƒ£ Difference between these slices
a = x[5:2];
a = x[2 +: 4];
a = x[5 -: 4];
Answer:
[5:2] â†’ bits 5,4,3,2
[2 +: 4] â†’ start=2, width=4 â†’ 5:2
[5 -: 4] â†’ start=5, width=4 â†’ 5:2
All three same result.

3ï¸âƒ£ Does order of always blocks matter in synthesis?
Answer:
No. RTL describes hardware. Synthesis does not consider ordering.
Only simulation ordering differs.
4ï¸âƒ£ Why is the following code bad in hardware design?
always @(*) begin
    a = b + c;
    b = a + d;
end
Answer:
Creates a combinational feedback loop â†’ unstable, non-synthesizable.

â­â­â­ L3 â€“ Hardcore (Qualcomm DSP / Nvidia GPU / AMD CPU level)
1ï¸âƒ£ Describe how non-blocking assignments are scheduled in Verilog simulation.
Events go through:
Active Region
Inactive Region
NBA Region
Monitor Region
Registers update in NBA, guaranteeing simultaneity.

2ï¸âƒ£ You have two sequential always blocks. Can their simulation order change the design?
Example:
always @(posedge clk) a <= b;
always @(posedge clk) b <= a;

Answer:No race.
Because both use non-blocking, so order doesnâ€™t matter.
Hardware = two flip-flops swapping values every cycle.

4ï¸âƒ£ What is a combinational cycle in RTL? Give an example and explain why it breaks STA.
Example:
assign x = y + 1;
assign y = x + 1;

Hardware cannot converge.
STA cannot compute a stable delay.

6ï¸âƒ£ DSP-style multiply-accumulate race question
always @(posedge clk)
    acc <= acc + (a * b);

Why might this fail timing?

Answer:
Because (a*b) is large combinational logic.
Critical path = multiply â†’ add â†’ register.

Fix using pipelining:
always @(posedge clk) mul <= a*b;
always @(posedge clk) acc <= acc + mul;

8ï¸âƒ£ Why should you avoid huge case statements in combinational logic?
Because:
synthesizes into deep mux tree
huge delay
poor timing
area explosion
possible latch inference if cases incomplete

9ï¸âƒ£ What does this Verilog slice mean?
ðŸ“¦ Example
Let:ACCW = 16, i = 3
Expression becomes:
acc_in_flat[3*16 +: 16] = acc_in_flat[48 +: 16]
Which means: acc_in_flat[63:48]

***************************************************************
is there any issue in below verilog code:
always @(*) begin
    a = b & c;
    b = a | d;
end
What is the issue?
Answer:
***************************************************************
If we have 2 "if-else" block inside an always block, how will they execute ?
Inside a single always block, all statements execute sequentially from top to bottom, in the order they are written â€” just like lines of C code.

So if you write two if-else blocks inside one always @(*) or always @(posedge clk) block:
always @(*) begin
    if (cond1)
        a = 1;
    else
        a = 0;

    if (cond2)
        b = 1;
    else
        b = 0;
end
âœ… Execution behavior

First if (cond1) is checked â†’ a is assigned.

Then after that, second if (cond2) is checked â†’ b is assigned.

They are not parallel.
They behave like:

1. evaluate cond1
2. assign a
3. evaluate cond2
4. assign b

â± In Combinational Logic (always @(*))
Even though the lines execute sequentially in simulation, the synthesized hardware is parallel combinational logic.
But the order still matters if one assignment depends on another, like:
x = y;
y = x;
or chained logic

â± In Sequential Logic (always @(posedge clk))
All non-blocking assignments (<=) update at the end of the clock, so order usually does not matter unless you use blocking (=), which can change behavior.
============================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================
============================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================
============================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================
You said:
in this code :
always @(posedge clk or negedge rst_n) begin
  if (!rst_n) begin
    out_data_reg <= 'b0;
    cntr <= 'b0;
  end else begin
    if (|in_data)  // if-block 1 
      cntr <= N;
    else
      cntr <= cntr - 1'b1;

    if (cntr == N)  // if block 2 
      out_data_reg <= in_data;
    else
      out_data_reg <= out_data_reg;
  end
end

Is there any fix topology, that "if-block 1" will execute first then "if-block 2" ?
or my question is which of these "if-block 1" or "if-block 2" will execute first?

Yes, there is a fixed execution order in simulation.

Inside an always block, statements execute sequentially, top â†’ bottom, just like software.

So:

if-block 1 executes first

if-block 2 executes second

Butâ€¦

Because you are using non-blocking (<=) assignments, the updates from if-block 1 do NOT take effect until the end of the clock tick.

So even though execution order is fixed, the value of cntr inside if-block 2 is still the old value, not the new one.
âœ”ï¸ Why?

Letâ€™s break down what happens at a posedge clock:

Step 1 â€” Simulation executes lines in order

It reaches if-block 1

Schedules cntr <= N or cntr <= cntr - 1

Then it reaches if-block 2

Checks if (cntr == N) using the old value of cntr

Step 2 â€” At the end of the timestep

All non-blocking assignments (<=) update simultaneously
â†’ cntr gets its new value
â†’ out_data_reg gets its new value

This matches real hardware: flops update only on the clock edge, not line-by-line.

âœ”ï¸ Final Answer
âœ”ï¸ The execution order is fixed, and if-block 1 runs before if-block 2.
âŒ But the value of cntr inside if-block 2 is still the old value, because <= delays the update

okay, so if here, we were using blocking assignment, then the updated value of cntr will have used in "if block 2" . right ?
âœ”ï¸ Yes â€” exactly right.

If you replace the non-blocking assignment:

cntr <= N;


with blocking assignment:

cntr = N;


then:

ðŸ‘‰ The updated value will be used immediately inside â€œif-block 2â€

because blocking assignments (=) update the variable right away during simulation.

âœ”ï¸ Example
Using blocking (=):
if (|in_data)        // if-block 1
    cntr = N;
else
    cntr = cntr - 1;

if (cntr == N)       // if-block 2
    out_data_reg <= in_data;

What happens?

if-block 1 runs first (because code is topâ†’bottom)

cntr is updated immediately

if-block 2 sees the new updated value of cntr
âœ”ï¸ Final Answer
âœ”ï¸ If using blocking (=), â€œif-block 2â€ will use the updated cntr value.
âŒ But you should never use blocking assignments in a clocked always block â€” it breaks hardware modeling.

